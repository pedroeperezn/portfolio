<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Pedro E. Perez: Professional portfolio</title>
  <link rel="stylesheet" href="./css/main.min.css">
  <link rel="stylesheet" href="./styles/style.css">
  <link rel="stylesheet" href="./prism/prism.css">
  <link rel="icon" href="./Images/game-controller.png" type="image/x-icon">
  
  




</head>
  
<body>

    <div id="page">
        
<!--========================================NavBar=================================================================-->
      <nav class="navbar navbar-expand-md navbar-light">
        <div class="container-xxl">

          <a href="./index.html" class="navbar-brand">
            <span class="fw-bold text-secondary">Pedro Enrique Perez</span>
          </a>

          <!--Toggle button for mobile navigation-->
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
          data-bs-target="#main-nav" aria-controls="main-nav" aria-expanded="false"
          aria-label="Toggle Navigation">
            <span class="navbar-toggler-icon"></span>
          </button>

          <!--LINKS IN THE NAVBAR -->
          <div class="collapse navbar-collapse justify-content-end align-center" id="main-nav">
            <ul class="navbar-nav">

              <li class="nav-item">
                <a href="./index.html" class="nav-link"> Home </a>
              </li>
              <li class="nav-item">
                <a href="#" class="nav-link"> Link2 </a>
              </li>
              <li class="nav-item">
                <a href="#" class="nav-link"> Link3 </a>
              </li>
            </ul>
          </div>
        
        </div>
      </nav>

<!--==========================================Content=======================================================================-->
    <main>

      <!--EXPLAIN WHICH WAS THE PROBLEM AND WHY/HOW TO FIX IT-->

      <!--ALSO TOOLS-->
    <section id="EMG" class="bg-dark">

      <div class="container-fluid">
        <div id="emgBanner" class="row banner">
        </div>
      </div>


        <div class="container-lg">
            <div class="row">
        <h2 class="text-light text-center my-2 p-5 display-2">Everything Must Go!</h2>
      <div class="col-12 mt-5">

        <p class="lead my-4 text-light text-justify">Everything Must Go! is an online multiplayer racing game in which players
          are contestants of a game show in which they must collect and checkout as many items as they can 
          before they run out of time. Players can also interfere with their rivals by ramming into, make them spill items and also grab and trigger power-ups.
        </p>

        <div class="embed-responsive embed-responsive-16by9 text-center mt-5">
          <iframe width="720px" height="480px" class="embed-responsive-item" src="https://www.youtube.com/embed/QuersdGu7Pw?si=T_filksnH0lpefds" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>

        <p class="lead my-4 text-light text-justify">
          <b class="display-6">The Challenge:</b>
          <br>
          <br>
          For this game, I programmed network multiplayer mechanics and implemented audio. This meant using replication and remote procedural calls
          in most mechanics in order to ensure that the most relevant information was correctly shared between server and clients. The mechanics with which I collaborated for the project
          were mainly related with item implementation and spawning, their collection and storage for players, scoring, collecting and using modifiers/power-ups, audio implementation, 
          UI programming and debug tools implementation using ImGUI. 
        </p>

      </div>

    </div>

    <div class="row g-5 py-5 justify-content-around">

<!--==================================== Accordion ======================================-->
<div class="col-12">
  <div class="accordion" id="EGMAccordion">

<!--==============================================Accordion item============================================================-->
<div class="accordion-item">
  <!--Header and button that will collapse or expand the accordion-->
  <h2 class="accordion-header" id="heading-1">
    <button class="accordion-button fw-bold collapsed" type="button" 
    data-bs-toggle="collapse" data-bs-target="#mechanics" 
    aria-expanded="true" aria-controls="mechanics"> <!-- TARGET = the id of the section that is going to toggle-->
    Shopping items | Player Inventory | Item Scoring
    </button>
  </h2>
  <!--Content of the accordion, declaring the id that we previously assigned-->
  <div id="mechanics" class="accordion-collapse 
  collapse hide" aria-labelledby="heading-1" data-bs-parent="#mechanics">
    <div class="accordion-body">
      
  <div class="list-group">
      <div class="list-group-item py-3">

        <!--
        <div class="text-center my-5">
          <iframe width="560" height="315" src="https://www.youtube.com/embed/D-UmfqFjpl0?si=Iu5HeIT2xuz2j3Je" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
      -->

        <h5 class="mb-1">The Idea</h5>


<p>
  The core game loop of "Everything Must Go!" is based on the idea of players going around the level looking for items, filling their shopping cart with them
  , and checking them out to score points. This implies that each player has a limited space for items that they can carry at a time and that 
  each item must have a size, a monetary value and weight that will affect the player's movement as the cart gets heavier/fuller.  
  In order to score, players should carry their items to the checkout stand, which should translate the monetary value of each product into the score and clear them 
  from the cart. 
</p>

<h5 class="my-4">Shopping Items</h5>

<p>
  Given that items will have size and monetary value, it would be fair for those values to be related, meaning that the bigger items should be heavier and award
  more points to the player given that they meant a bigger sacrifice to carry around. 
  We also had the goal of making items easily accessible in editor, modifiable and expandable in order for our team's game designers to be able to
  easily add and tune the data of each item. In order to achieve this, we decided to use 
  Unreal Engine's Data Tables:
</p>

<div class="text-center my-5">
  <img class="img-fluid" src="./Images/EMG/emgDataTables.PNG">
</div>

<p>Once the items were defined in the data tables, I created a C++ class for them including the data we exposed on the tables: </p>
<!--======================================================================Shopping Item Sample Code=================================================================================-->
<pre class="pre-scrollable"><code class=" language-cpp">
        
  // Copyright (c) 2023 @ Runaway Concepts

  #pragma once
  
  #include "CoreMinimal.h"
  #include "EverythingMustGo/Components/EMGItemSpawner.h"
  #include "EverythingMustGo/Interfaces/InteractInterface.h"
  #include "GameFramework/Actor.h"
  #include "EverythingMustGo/Public/EMGUtils.h"
  
  
  #include "ShoppingItem.generated.h"
  
  class UNiagaraSystem;
  
  UCLASS()
  class EVERYTHINGMUSTGO_API AShoppingItem : public AActor, public IInteractInterface
  {
    GENERATED_BODY()
    
  public:	
    // Sets default values for this actor's properties
    AShoppingItem();
  
    virtual void GetLifetimeReplicatedProps(TArray&ltFLifetimeProperty&gt& OutLifetimeProps) const override;
    
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite)
    UNiagaraComponent* NiagaraComponent;
    
    //Struct used in the player inventory to keep track of amount of items
    UPROPERTY(EditAnywhere,BlueprintReadWrite)
    FItemsInInventory Item;
  
    UPROPERTY(EditAnywhere,BlueprintReadWrite)
    AEMGItemSpawner* ItemSpawner;
  
    UFUNCTION(NetMulticast,Reliable)
    void SetParticle(UNiagaraSystem* _NS);
  
    UPROPERTY(BlueprintReadWrite, ReplicatedUsing=OnRep_Change)
    UNiagaraSystem* NS;
  
    UFUNCTION()
    void OnRep_Change(UNiagaraSystem* _NS);
    
  };
  
</code></pre>
<!--==============================================================================================================================================================================-->

<br>
<p>I also created a helper struct called FItemsInInventory, which would be the way in which the player could store the essential information of each shopping item they picked up:</p>
<br>

<!--===================================================================================================================================-->
<pre class="pre-scrollable"><code class=" language-cpp">  
  USTRUCT(BlueprintType)
  struct FItemsInInventory : public FTableRowBase
  {
  
    GENERATED_BODY()
    
    UPROPERTY(EditAnywhere, BlueprintReadOnly)
    FString ItemType;
  
    UPROPERTY(EditAnywhere, BlueprintReadOnly)
    float Value;
  
    UPROPERTY(EditAnywhere,BlueprintReadOnly)
    TEnumAsByte&ltEItemSize&gt ItemSize;
  
    UPROPERTY(EditAnywhere,BlueprintReadWrite)
    UStaticMesh* ItemMesh;
    
    UPROPERTY(EditAnywhere,BlueprintReadWrite)
    UNiagaraSystem* NiagaraParticles;
    
  };
  </code></pre>
<!--===================================================================ITEM SPAWNER========================================================================================-->
<br>
<h5 class="my-4">Item Spawning</h5>

<p>
  For spawning items, I engineered an actor that would serve as a spawner. Said spawner should be able to grab data from a selected data table assignable in editor,
  set properties for a "ShoppingItem" actor, and spawn them constantly at a fixed amount of time.
</p>
<br>

<!--====================================================Item Spawner Sample Code===================================================================-->
<pre class="pre-scrollable"><code class=" language-cpp">  
void AEMGItemSpawner::Server_Spawn_Implementation()
{
  //Check if the spawner is going to be a shopping item and that the spawner is enabled
  if(bCanSpawn && TypeOfSpawnable == ETypoeOfSpawnable::ShoppingItem)
  {
    //Set spawning parameters
    FActorSpawnParameters ActorSpawnParams;
    ActorSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
  
    //Make sure that the data table was assigned
    if(!ItemDataTable)
    {
      UE_LOG(LogTemp,Warning,TEXT("No data table loaded"));
      return;
    }
  
    //Check how many different items are there in the DT
    TArray&ltFName&gt ItemsInDT = ItemDataTable->GetRowNames();
    int32 NumberOfItems = ItemsInDT.Num();
  
    if(NumberOfItems == 0)
    {
      UE_LOG(LogTemp,Warning,TEXT("Empty Data Table"));
      return;
    }
  
    //Create a new item with the properties of a random row in the DT
    int32 RandomItemNumber = FMath::RandRange(0, NumberOfItems-1);
    FItemsInInventory* newItem = ItemDataTable->FindRow&ltFItemsInInventory&gt(ItemsInDT[RandomItemNumber],TEXT("Looking for random item"));
    
    
    checkf(newItem, TEXT("Error loading item from Data Table to spawn item"));
  
    ItemsInInventory = *newItem;
  
    //Spawn shopping item with properties from the data table row
    AShoppingItem* ShoppingItem = GetWorld()->SpawnActor&ltAShoppingItem&gt(ItemToSpawnBP,
      BillboardComponent->GetComponentLocation(),
      BillboardComponent->GetComponentRotation(), ActorSpawnParams);
  
    if(ShoppingItem)
    {
      ShoppingItem->Item = ItemsInInventory;
  
      ShoppingItem->FindComponentByClass&ltUStaticMeshComponent&gt()->SetStaticMesh(ItemsInInventory.ItemMesh);
      ShoppingItem->SetParticle(ItemsInInventory.NiagaraParticles);
      
      ShoppingItem->ItemSpawner = this;
      bCanSpawn = false;

      if(ShoppingItem->Item.ItemSize == EItemSize::Large)
      {
        PlayHighValueAudioCue();
      }
    }
  }
}
</code></pre>
<!--==========================================================================================================================================================-->

<br>
<h5 class="my-4">Player Inventory</h5>
<p>  
  The player inventory is the UActorComponent responsible for keeping track of how many and which items the player is carrying at a given time in their cart. 
  It holds all the information regarding cart capacity, cart's remaining space, current stored value, and also declares functions that will place items new items into the cart,
  remove them, or empty it. 
</p>
<br>

<!--===================================================================Inventory Component========================================================================================-->
<pre class="pre-scrollable"><code class=" language-cpp">  
// Copyright (c) 2023 @ Runaway Concepts
#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "EMGUtils.h"

#include "EMGPlayerInventory.generated.h"


DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAddInventoryItem, FItemsInInventory, ItemAdded);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRemoveInventoryItem, FItemsInInventory, ItemRemoved);
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnCheckOut);


UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class EVERYTHINGMUSTGO_API UEMGPlayerInventory : public UActorComponent
{
  GENERATED_BODY()

public:	
  // Sets default values for this component's properties
  UEMGPlayerInventory();

  UPROPERTY(EditAnywhere,BlueprintReadWrite)
  float InventoryCapacity = 10;

  UPROPERTY()
  float InitialInventoryCapacity;

  UPROPERTY(EditAnywhere,BlueprintReadWrite)
  float ItemCount;
  
  UPROPERTY(EditAnywhere,BlueprintReadWrite)
  float ItemSpace;

  UPROPERTY()
  bool bIsWeightAffectingMovement = true;

  UPROPERTY(EditAnywhere,BlueprintReadWrite)
  TArray&ltFItemsInInventory&gt PlayerInventory;
  
  UPROPERTY(EditAnywhere,BlueprintReadWrite)
  float TotalValueCollected;

  UPROPERTY(BlueprintReadOnly)
  ACharacter* PlayerRef;

  UFUNCTION(Server,Reliable,BlueprintCallable)
  void Server_AddItemToInventory(FItemsInInventory ItemToAdd);
  
  UFUNCTION(NetMulticast, Reliable,BlueprintCallable)
  void Multicast_AddToInventory(FItemsInInventory ItemsInInventory);

  UFUNCTION(Server,Reliable,BlueprintCallable)
  void Server_AddMultipleItemsToInventory(const TArray&ltFItemsInInventory&gt& ItemsToAdd);

  UFUNCTION(NetMulticast, Reliable,BlueprintCallable)
  void Multicast_AddMultipleItemsToInventory(const TArray&ltFItemsInInventory&gt& ItemsToAdd);

  UFUNCTION(Server,Reliable,BlueprintCallable)
  void Server_RemoveLastItem();
  
  UFUNCTION(NetMulticast,Reliable,BlueprintCallable)
  void MulticastRemoveLastItem();

  UFUNCTION(Server,Reliable,BlueprintCallable)
  void Server_RemoveFirstItem();
  
  UFUNCTION(NetMulticast,Reliable,BlueprintCallable)
  void MulticastRemoveFirstItem();

  UFUNCTION()
  void UpdateTotalValueCollected();


  UFUNCTION(Server,Reliable, BlueprintCallable)
  void Server_EmptyInventory();

  UFUNCTION(NetMulticast,Reliable)
  void Multicast_EmptyInventory();

  UFUNCTION()
  void UpdatePlayersCartWeight();

  UFUNCTION(BlueprintCallable)
  FORCEINLINE bool IsFull() const
  {
    return ItemSpace == 0;
  }

  UPROPERTY(BlueprintAssignable)
  FOnAddInventoryItem OnAddItemToInventory;
  UPROPERTY(BlueprintAssignable)
  FOnRemoveInventoryItem OnRemoveInventoryItem;
  UPROPERTY(BlueprintAssignable)
  FOnCheckOut OnCheckOut;

protected:

  // Called when the game starts
  virtual void BeginPlay() override;

  UPROPERTY(EditAnywhere,BlueprintReadOnly, Category="Item Slowdown Multipliers")
  float MaxAccelerationMutliplier;

  UPROPERTY(EditAnywhere,BlueprintReadOnly, Category="Item Slowdown Multipliers")
  float MaxSpeedMultiplier;

  UPROPERTY(EditAnywhere,BlueprintReadOnly, Category="Item Slowdown Multipliers")
  float MassMultiplier;

  UPROPERTY(EditAnywhere,BlueprintReadOnly, Category="Item Slowdown Multipliers")
  float FrictionMultiplier;

public:	
  // Called every frame
  virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

    
};
</code></pre>
<!--=======================================================================================================================================================================-->

<h5 class="my-4">Collecting Items</h5>
<p>  
  The method for storing items into the cart is fairly simple. Each Shopping Item holds a variable of the FItemsInInventory type which, when a player interacts with it (and if there is
  still space remaining for the item in the inventory), will be copied into an array of FItemsInInventory inside of the player inventory. In order for the server and clients to 
  have proper knowledge of the item that was stored and it's weight, size and monetary values, the function needed to be called with an RPC:

</p>
<br>
<!--====================================================Add item to inventory RPC===================================================================-->

<pre class="pre-scrollable"><code class=" language-cpp">  
void UEMGPlayerInventory::Server_AddItemToInventory_Implementation(FItemsInInventory ItemToAdd)
{
  Multicast_AddToInventory(ItemToAdd);
}

//Adds new collected item to the players inventory
void UEMGPlayerInventory::Multicast_AddToInventory_Implementation(FItemsInInventory ItemsInInventory)
{
	//Add the new item as a copy
	ItemCount += ItemsInInventory.ItemSize;
	ItemSpace -= ItemsInInventory.ItemSize;

	PlayerInventory.Add(ItemsInInventory);
	UpdateTotalValueCollected();
	OnAddItemToInventory.Broadcast(ItemsInInventory);

	//TODO: Implement logic for affecting the players movement
	UpdatePlayersCartWeight();
}
</code></pre>
<!--==========================================================================================================================================================-->
<div class="my-5">
  <div class="row text-center">
    <div class="col-3"></div>
    <img src="./Images/EMG/emgCollectItemGIF.gif" class="img-fluid col-6">
  </div>
</div>


      </div>
    </div>
  </div>
</div>

<!--==============================================================POWERUPS==============================================================================-->

<div class="accordion-item">
  <!--Header and button that will collapse or expand the accordion-->
  <h2 class="accordion-header" id="heading-1">
    <button class="accordion-button fw-bold collapsed" type="button" 
    data-bs-toggle="collapse" data-bs-target="#powerups" 
    aria-expanded="true" aria-controls="powerups"> <!-- TARGET = the id of the section that is going to toggle-->
    Powerups
    </button>
  </h2>
  <!--Content of the accordion, declaring the id that we previously assigned-->
  <div id="powerups" class="accordion-collapse 
  collapse hide" aria-labelledby="heading-1" data-bs-parent="#powerups">
    <div class="accordion-body">
      
  <div class="list-group">
      <div class="list-group-item py-3">

        <!--
        <div class="text-center my-5">
          <iframe width="560" height="315" src="https://www.youtube.com/embed/D-UmfqFjpl0?si=Iu5HeIT2xuz2j3Je" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
      -->

<h5 class="mb-1">The Idea</h5>

<p>
  In order for gameplay to have more variation and possibilities, as well as for implementing a catch up mechanics, we decided to design a power up system based 
  on existing mechanics that could enhance the player's abilities momentarily in order to gain advantage over the others. The design team decided that we were going
  to work in 5 power-ups:

  <ul>
    <li>Speed Boost: The player's acceleration and maximum speed would increase considerably.</li>
    <li>Shield: The player would be immune to ramming (can't loose items nor be propelled when attacked by other players).</li>
    <li>Infinite Inventory: The player's cart would have a very big cap on the items they can carry, making it practically limitless.</li>
    <li>Spawn Goo Trap: The player can spawn behind they a trap that will make players get stuck momentarily.</li>
    <li>Spawn Slippery Trap: The player can spawn behind they a trap that will make other players spin and loose control of the cart momentarily. </li>
  </ul>

  In order to achieve so, I designed a system that took advantage of the spawning logic that was previously used for spawning shopping items, 
  as well as engineered and implemented a power-up actor component that was in charge of the logic of assigning and using power-ups.

</p>

<!--===================================================Spawn powerup pickup==================================================================================-->

<h5 class="my-4">Power Up Pickup</h5>
<p>
The way in which players can get a power-up assigned is by colliding with a power-up pickup, which are spawned in the level in a very similar fashion that
the shopping items. I created a "EMGPowerupPickup" class which inherits from the "ShoppingItem" class. This made spawning power-up pickups easy, accessible in editor,
and familiar to my Level Designer, who only needed to indicate the spawner that this spawner would be for power-up pickups and the spawner did the rest:
</p>

<!--======================================================================Spawn Powerup Code=================================================================================-->
<pre class="pre-scrollable"><code class=" language-cpp">

//Check if the assigned type of item is a shopping item or a power-up pickup
else if(bCanSpawn && TypeOfSpawnable == ETypoeOfSpawnable::Powerup )
{
  //Set spawning param
	FActorSpawnParameters ActorSpawnParams;
	ActorSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
	
	AEMG_PowerupPickup* Powerup = GetWorld()->SpawnActor&ltAEMG_PowerupPickup&gt(ItemToSpawnBP,
	BillboardComponent->GetComponentLocation(),
	BillboardComponent->GetComponentRotation(), ActorSpawnParams);
	if(Powerup)
	{
		Powerup->ItemSpawner = this;
		bCanSpawn = false;
	}
}      
</code></pre>

<div class="my-5">
  <div class="row text-center">
    <div class="col-3"></div>
    <img src="./Images/EMG/EMGPowerupPickup.png" class="img-fluid col-6">
  </div>
</div>

<!--======================================================================Powerup assigning==================================================================================-->
<h5 class="my-4">Assigning power-ups</h5>
<p>
If the player isn't already a power-up holder, whenever colliding with a power-up pickup a power-up will be assigned to them. The assignment of the power-up depends on
the current scores on the match, making that players with bigger scores will most likely be assigned the Goo Bomb or the Slippery Trap. Players with an average scores will
have a tendency to be assigned the super speed power-up, and players that are behind in score will be more likely to be assigned either infinite inventory or the shield,
which can potentially give a greater advantage on the match. 
</p>

<h6 class="my-4">Get Match's Score Average</h6>
<pre class="pre-scrollable"><code class=" language-cpp"> 

//Get average scores on match
int UEMGPowerup::GetPlayerScoreAverage()
{
	int ScoreSum = 0;
	int ScoreAverage = 0;
	
  //Get player array
	TArray&ltAPlayerState&gt PlayerStates = GetWorld()->GetGameState()->PlayerArray;
	
	if(PlayerStates.Num() == 0)
	{
		return 0;
	}

  //for each player, get their score and add them to a sum, for later getting the average score
	for (auto PlayerState : PlayerStates)
	{
		ScoreSum += PlayerState->GetScore();
	}

	ScoreAverage = ScoreSum/PlayerStates.Num();

	return ScoreAverage;
}
</code></pre>

<h6 class="my-4">Get powerup based on scores</h6>
<pre class="pre-scrollable"><code class=" language-cpp"> 

//Get the power-up that is going to be assigned to the player 
EPowerUpType UEMGPowerup::GetRandomPowerup()
{
  //Get score average in match
  float avgScore = GetPlayerScoreAverage();

  //Tiers probability of power-up per tier (tier1 is More Useful, tier3 is less useful)
  float tier1 = 0.25;
  float tier2 = 0.35;
  float tier3 = 0.40;

  if(!PlayerRef)
  {
    return EPowerUpType::None;
  }
  
  //Depending on the player's score compared with the average, assign more probability to specific power-up tiers
  if(PlayerRef->GetPlayerState()->GetScore() < avgScore * 0.5)
  {
    tier1 += 0.35;
    tier2 -= 0.10;
    tier3 -= 0.25;
  }

  if(PlayerRef->GetPlayerState()->GetScore() > avgScore * 0.5)
  {
    tier1 -= 0.1;
    tier2 -= 0.1;
    tier3 += 0.2;
  }

  //generate a random number from 0 to 1 and then compare with the tier values, having probability depending on how players were doing on the match
  float RandomTierValue = FMath::FRand();

  if(RandomTierValue < tier1)
  {
    //assign powerup between InfiniteInventory and Shield	
    int32 RandomValue = FMath::RandRange(static_cast&ltint32&gt(EPowerUpType::InfiniteInventory),static_cast&ltint32&gt(EPowerUpType::Shield));
    return static_cast&ltEPowerUpType&gt(RandomValue);
  }

  if(RandomTierValue < tier1 + tier2)
  {
    //assign SpeedBoost
    return EPowerUpType::SpeedBoost;
  }

  else
  {
    //assign between Slippery and Gooey
    int32 RandomValue = FMath::RandRange(static_cast&ltint32&gt(EPowerUpType::Slippery),static_cast&ltint32&gt(EPowerUpType::Gooey));
    return static_cast&ltEPowerUpType&gt(RandomValue);
  }
}
</code></pre>

<p>Once the selection of the power-up has been done, I implemented a RPC that allows the server assign the power-up that was assigned to the player and 
  communicates it to them. 
</p>

<pre class="pre-scrollable"><code class="language-cpp">
UFUNCTION(Server,Reliable,BlueprintCallable)
void Server_AssignPlayerPowerup();
UFUNCTION(NetMulticast,Reliable)
void Multicast_AssignPlayerPowerup(EPowerUpType PowerupToAssign);
</code></pre>

<pre class="pre-scrollable"><code class="language-cpp">
void UEMGPowerup::Server_AssignPlayerPowerup_Implementation()
{
  EPowerUpType AssignedPowerup = GetRandomPowerup();
  Multicast_AssignPlayerPowerup(AssignedPowerup);
}

void UEMGPowerup::Multicast_AssignPlayerPowerup_Implementation(EPowerUpType PowerupToAssign)
{
  CurrentPowerup = PowerupToAssign;
}
</code></pre>

<div class="my-5">
  <div class="row text-center">
    <div class="col-3"></div>
    <img src="./Images/EMG/EMGPickupPowerupGIF.gif" class="img-fluid col-6">
  </div>
</div>

<!--======================================================================Powerup Usage==================================================================================-->
<h5 class="my-4">Using Power-ups</h5>
<p>When a player has a power-up assigned, they can use the power-up input action, which will trigger whichever
  power-up the player has currently assigned. In order to correctly execute the modifier that the player has assigned,
  we engineered a data structure that holds all the possible power-ups available and the component has a variable that 
  of said type that stores which is the current power-up that the player can make use of. If the player triggers a power-up and 
  has one currently assigned, the <b>UsePowerup()</b> RPC method will be called, which will trigger the corresponding modifier depending on
  the current power-up variable. For the power-ups that have a time duration, I decided to make use of a timer that will call
  the <b>RevertPowerup()</b> RPC that, with a very similar logic, will check which is the current active power-up and revert it's 
  effects once the specified time has finished. 
</p>

<h6 class="my-4">Use power-up server call</h6>
<pre class="pre-scrollable"><code class="language-cpp">
//Server call for using power-up
UFUNCTION(Server, Reliable, BlueprintCallable)
void Server_UsePowerup();
</code></pre>

<h6 class="my-4">Use power-up logic</h6>
<pre class="pre-scrollable"><code class="language-cpp">
void UEMGPowerup::Server_UsePowerup_Implementation()
{
  //Check which is the current assigned power-up
  switch (CurrentPowerup)
  {
  
  //Speed power-up call  
  case EPowerUpType::SpeedBoost:
    {
      Server_SpeedPowerup();
      GetWorld()->GetTimerManager().SetTimer(PowerupTimerHandle,this, &UEMGPowerup::Server_RevertPowerup,SpeedPowerupDuration,false);
      OnPlaySpeedCue.Broadcast();
      break;
    }
      
  //Infinite inventory power-up call  
  case EPowerUpType::InfiniteInventory:
    {
      InfiniteInventory();
      //CurrentPowerupDuration = InventoryPowerupDuration;
      GetWorld()->GetTimerManager().SetTimer(PowerupTimerHandle,this, &UEMGPowerup::Server_RevertPowerup,InventoryPowerupDuration,false);
      OnPlayInfiniteCue.Broadcast();
      break;
    }

  //Shield power-up call
  case EPowerUpType::Shield:
    {
      Server_UseShieldPowerup();
      GetWorld()->GetTimerManager().SetTimer(PowerupTimerHandle,this, &UEMGPowerup::Server_RevertPowerup,ShieldPowerupDuration,false);
      OnPlayShieldCue.Broadcast();
      break;
    }

  //Goo trap power-up call
  case EPowerUpType::Gooey:
    {
      if(!GooeyHazardRef)
      {
        return;
      }
      if(!PowerupSpawn)
      {
        return;
      }
      
      FVector spawningLocation = PowerupSpawn->GetComponentLocation();
      AEMG_ObstacleHazard* GooeyHazard = GetWorld()->SpawnActor&ltAEMG_ObstacleHazard&gt(GooeyHazardRef,spawningLocation,
        GetOwner()->GetActorRotation(),PowerupSpawnParams);

      OnPlayGooeyCue.Broadcast();
      Server_RevertPowerup();
      break;
    }

  //Slippery trap power-up call
  case EPowerUpType::Slippery:
    {
      if(!SlipperyHazardRef)
      {
        return;
      }
      if(!PowerupSpawn)
      {
        return;
      }
      
      FVector spawningLocation = PowerupSpawn->GetComponentLocation();
      AEMG_SlipperyHazzard* slipperyHazard = GetWorld()->SpawnActor&ltAEMG_SlipperyHazzard&gt(SlipperyHazardRef,spawningLocation,
        GetOwner()->GetActorRotation(),PowerupSpawnParams);

      OnPlaySlipperyCue.Broadcast();
      Server_RevertPowerup();
      break;
    }
    
  }
}
</code></pre>

<h6 class="my-4">Revert Powerup RPC Call</h6>
<pre class="pre-scrollable"><code class="language-cpp">
UFUNCTION(Server,Reliable,BlueprintCallable)
void Server_RevertPowerup();
UFUNCTION(NetMulticast,Reliable)
void Multicast_RevertPowerup();  
</code></pre>

<h6 class="my-4">Revert power-up logic</h6>
<pre class="pre-scrollable"><code class="language-cpp">
void UEMGPowerup::Server_RevertPowerup_Implementation()
{
  Multicast_RevertPowerup();
}

void UEMGPowerup::Multicast_RevertPowerup_Implementation()
{
  
  switch (CurrentPowerup)
  {
    case EPowerUpType::SpeedBoost:
      RevertSpeedPowerup();
      OnStopSpeedCue.Broadcast();
      break;
    
    case EPowerUpType::InfiniteInventory:
      RevertInfiniteInventory();
      OnStopInfiniteCue.Broadcast();
      break;

    case EPowerUpType::Shield:
      OnStopShieldCue.Broadcast();
      break;
    
  }
  
  CurrentPowerup = EPowerUpType::None;
  PlayerRef->ResetPowewrupWidget();
  CurrentPowerupDuration = 0;
} 
</code></pre>



      </div>
    </div>
  </div>
</div>



<!--======================================================================================================================================-->




    </div>
  </div>
</div>

<!---------------------------------------------------End of accordion--------------------------------------------------------->
    
<div class="text-center my-5">
  <a href="https://vfs-gdpg.itch.io/everything-must-go" class="btn btn-primary">Link to VFS Arcade</a>
</div>

    </div> 
    </div>
    </section>
  
    </main>
<!--=========================================================================================================================-->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
<script src="./scripts/index.js"></script>
<script src="./prism/prism.js"></script>
</body>
</html>