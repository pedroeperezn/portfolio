<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Pedro E. Perez: Professional portfolio</title>
  <link rel="stylesheet" href="./css/main.min.css">
  <link rel="stylesheet" href="./styles/style.css">
  <link rel="stylesheet" href="./prism/prism.css">
  <link rel="icon" href="./Images/game-controller.png" type="image/x-icon">
  
  




</head>
  
<body>

    <div id="page">
        
<!--========================================NavBar=================================================================-->
      <nav class="navbar navbar-expand-md navbar-light">
        <div class="container-xxl">

          <a href="./index.html" class="navbar-brand">
            <span class="fw-bold text-secondary">Pedro Enrique Perez</span>
          </a>

          <!--Toggle button for mobile navigation-->
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
          data-bs-target="#main-nav" aria-controls="main-nav" aria-expanded="false"
          aria-label="Toggle Navigation">
            <span class="navbar-toggler-icon"></span>
          </button>

          <!--LINKS IN THE NAVBAR -->
          <div class="collapse navbar-collapse justify-content-end align-center" id="main-nav">
            <ul class="navbar-nav">

              <li class="nav-item">
                <a href="./index.html" class="nav-link"> Home </a>
              </li>
              <li class="nav-item">
                <a href="#" class="nav-link"> Link2 </a>
              </li>
              <li class="nav-item">
                <a href="#" class="nav-link"> Link3 </a>
              </li>
            </ul>
          </div>
        
        </div>
      </nav>

<!--==========================================Content=======================================================================-->
    <main>

      <!--EXPLAIN WHICH WAS THE PROBLEM AND WHY/HOW TO FIX IT-->

      <!--ALSO TOOLS-->
    <section id="EMG" class="bg-dark">

      <div class="container-fluid">
        <div id="emgBanner" class="row banner">
        </div>
      </div>


        <div class="container-lg">
            <div class="row">
        <h2 class="text-light text-center my-2 p-5 display-2">Everything Must Go!</h2>
      <div class="col-12 mt-5">

        <p class="lead my-4 text-light text-justify">Everything Must Go! is an online multiplayer racing game in which players
          are contestants of a game show in which they must collect and checkout as many items as they can 
          before they run out of time. Players can also interfere with their rivals by ramming into, make them spill items and also grab and trigger power-ups.
        </p>

        <div class="embed-responsive embed-responsive-16by9 text-center mt-5">
          <iframe width="720px" height="480px" class="embed-responsive-item" src="https://www.youtube.com/embed/QuersdGu7Pw?si=T_filksnH0lpefds" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>

        <p class="lead my-4 text-light text-justify">
          <b class="display-6">The Challenge:</b>
          <br>
          <br>
          For this game, I programmed network multiplayer mechanics and implemented audio. This meant using replication and remote procedural calls
          in most mechanics in order to ensure that the most relevant information was correctly shared between server and clients. The mechanics with which I collaborated for the project
          were mainly related with item implementation and spawning, their collection and storage for players, scoring, collecting and using modifiers/power-ups, audio implementation, 
          UI programming and debug tools implementation using ImGUI. 
        </p>

      </div>

    </div>

    <div class="row g-5 py-5 justify-content-around">

<!--==================================== Accordion ======================================-->
<div class="col-12">
  <div class="accordion" id="EGMAccordion">

<!--==============================================Accordion item============================================================-->
<div class="accordion-item">
  <!--Header and button that will collapse or expand the accordion-->
  <h2 class="accordion-header" id="heading-1">
    <button class="accordion-button fw-bold collapsed" type="button" 
    data-bs-toggle="collapse" data-bs-target="#mechanics" 
    aria-expanded="true" aria-controls="mechanics"> <!-- TARGET = the id of the section that is going to toggle-->
    Shopping items | Player Inventory | Item Scoring
    </button>
  </h2>
  <!--Content of the accordion, declaring the id that we previously assigned-->
  <div id="mechanics" class="accordion-collapse 
  collapse hide" aria-labelledby="heading-1" data-bs-parent="#mechanics">
    <div class="accordion-body">
      
  <div class="list-group">
      <div class="list-group-item py-3">

        <!--
        <div class="text-center my-5">
          <iframe width="560" height="315" src="https://www.youtube.com/embed/D-UmfqFjpl0?si=Iu5HeIT2xuz2j3Je" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
      -->

        <h5 class="mb-1">The Idea</h5>


<p>
  The core game loop of "Everything Must Go!" is based on the idea of players going around the level looking for items, filling their shopping cart with them
  , and checking them out to score points. This implies that each player has a limited space for items that they can carry at a time and that 
  each item must have a size, a monetary value and weight that will affect the player's movement as the cart gets heavier/fuller.  
  In order to score, players should carry their items to the checkout stand, which should translate the monetary value of each product into the score and clear them 
  from the cart. 
</p>

<h5 class="my-4">Shopping Items</h5>

<p>
  Given that items will have size and monetary value, it would be fair for those values to be related, meaning that the bigger items should be heavier and award
  more points to the player given that they meant a bigger sacrifice to carry around. 
  We also had the goal of making items easily accessible in editor, modifiable and expandable in order for our team's game designers to be able to
  easily add and tune the data of each item. In order to achieve this, we decided to use 
  Unreal Engine's Data Tables:
</p>

<div class="text-center my-5">
  <img class="img-fluid" src="./Images/EMG/emgDataTables.PNG">
</div>

<p>Once the items were defined in the data tables, I created a C++ class for them including the data we exposed on the tables: </p>
<!--======================================================================Shopping Item Sample Code=================================================================================-->
<pre class="pre-scrollable"><code class=" language-cpp">
        
  // Copyright (c) 2023 @ Runaway Concepts

  #pragma once
  
  #include "CoreMinimal.h"
  #include "EverythingMustGo/Components/EMGItemSpawner.h"
  #include "EverythingMustGo/Interfaces/InteractInterface.h"
  #include "GameFramework/Actor.h"
  #include "EverythingMustGo/Public/EMGUtils.h"
  
  
  #include "ShoppingItem.generated.h"
  
  class UNiagaraSystem;
  
  UCLASS()
  class EVERYTHINGMUSTGO_API AShoppingItem : public AActor, public IInteractInterface
  {
    GENERATED_BODY()
    
  public:	
    // Sets default values for this actor's properties
    AShoppingItem();
  
    virtual void GetLifetimeReplicatedProps(TArray&ltFLifetimeProperty&gt& OutLifetimeProps) const override;
    
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite)
    UNiagaraComponent* NiagaraComponent;
    
    //Struct used in the player inventory to keep track of amount of items
    UPROPERTY(EditAnywhere,BlueprintReadWrite)
    FItemsInInventory Item;
  
    UPROPERTY(EditAnywhere,BlueprintReadWrite)
    AEMGItemSpawner* ItemSpawner;
  
    UFUNCTION(NetMulticast,Reliable)
    void SetParticle(UNiagaraSystem* _NS);
  
    UPROPERTY(BlueprintReadWrite, ReplicatedUsing=OnRep_Change)
    UNiagaraSystem* NS;
  
    UFUNCTION()
    void OnRep_Change(UNiagaraSystem* _NS);
    
  };
  
</code></pre>
<!--==============================================================================================================================================================================-->

<br>
<p>I also created a helper struct called FItemsInInventory, which would be the way in which the player could store the essential information of each shopping item they picked up:</p>
<br>

<!--===================================================================================================================================-->
<pre class="pre-scrollable"><code class=" language-cpp">  
  USTRUCT(BlueprintType)
  struct FItemsInInventory : public FTableRowBase
  {
  
    GENERATED_BODY()
    
    UPROPERTY(EditAnywhere, BlueprintReadOnly)
    FString ItemType;
  
    UPROPERTY(EditAnywhere, BlueprintReadOnly)
    float Value;
  
    UPROPERTY(EditAnywhere,BlueprintReadOnly)
    TEnumAsByte&ltEItemSize&gt ItemSize;
  
    UPROPERTY(EditAnywhere,BlueprintReadWrite)
    UStaticMesh* ItemMesh;
    
    UPROPERTY(EditAnywhere,BlueprintReadWrite)
    UNiagaraSystem* NiagaraParticles;
    
  };
  </code></pre>
<!--===================================================================ITEM SPAWNER========================================================================================-->
<br>
<h5 class="my-4">Item Spawning</h5>

<p>
  For spawning items, I engineered an actor that would serve as a spawner. Said spawner should be able to grab data from a selected data table assignable in editor,
  set properties for a "ShoppingItem" actor, and spawn them constantly at a fixed amount of time.
</p>
<br>

<!--====================================================Item Spawner Sample Code===================================================================-->
<pre class="pre-scrollable"><code class=" language-cpp">  
void AEMGItemSpawner::Server_Spawn_Implementation()
{
  //Check if the spawner is going to be a shopping item and that the spawner is enabled
  if(bCanSpawn && TypeOfSpawnable == ETypoeOfSpawnable::ShoppingItem)
  {
    //Set spawning parameters
    FActorSpawnParameters ActorSpawnParams;
    ActorSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
  
    //Make sure that the data table was assigned
    if(!ItemDataTable)
    {
      UE_LOG(LogTemp,Warning,TEXT("No data table loaded"));
      return;
    }
  
    //Check how many different items are there in the DT
    TArray&ltFName&gt ItemsInDT = ItemDataTable->GetRowNames();
    int32 NumberOfItems = ItemsInDT.Num();
  
    if(NumberOfItems == 0)
    {
      UE_LOG(LogTemp,Warning,TEXT("Empty Data Table"));
      return;
    }
  
    //Create a new item with the properties of a random row in the DT
    int32 RandomItemNumber = FMath::RandRange(0, NumberOfItems-1);
    FItemsInInventory* newItem = ItemDataTable->FindRow&ltFItemsInInventory&gt(ItemsInDT[RandomItemNumber],TEXT("Looking for random item"));
    
    
    checkf(newItem, TEXT("Error loading item from Data Table to spawn item"));
  
    ItemsInInventory = *newItem;
  
    //Spawn shopping item with properties from the data table row
    AShoppingItem* ShoppingItem = GetWorld()->SpawnActor&ltAShoppingItem&gt(ItemToSpawnBP,
      BillboardComponent->GetComponentLocation(),
      BillboardComponent->GetComponentRotation(), ActorSpawnParams);
  
    if(ShoppingItem)
    {
      ShoppingItem->Item = ItemsInInventory;
  
      ShoppingItem->FindComponentByClass&ltUStaticMeshComponent&gt()->SetStaticMesh(ItemsInInventory.ItemMesh);
      ShoppingItem->SetParticle(ItemsInInventory.NiagaraParticles);
      
      ShoppingItem->ItemSpawner = this;
      bCanSpawn = false;

      if(ShoppingItem->Item.ItemSize == EItemSize::Large)
      {
        PlayHighValueAudioCue();
      }
    }
  }
}
</code></pre>
<!--==========================================================================================================================================================-->

<br>
<h5 class="my-4">Player Inventory</h5>
<p>  
  The player inventory is the UActorComponent responsible for keeping track of how many and which items the player is carrying at a given time in their cart. 
  It holds all the information regarding cart capacity, cart's remaining space, current stored value, and also declares functions that will place items new items into the cart,
  remove them, or empty it. 
</p>
<br>

<!--===================================================================Inventory Component========================================================================================-->
<pre class="pre-scrollable"><code class=" language-cpp">  
// Copyright (c) 2023 @ Runaway Concepts
#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "EMGUtils.h"

#include "EMGPlayerInventory.generated.h"


DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAddInventoryItem, FItemsInInventory, ItemAdded);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRemoveInventoryItem, FItemsInInventory, ItemRemoved);
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnCheckOut);


UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class EVERYTHINGMUSTGO_API UEMGPlayerInventory : public UActorComponent
{
  GENERATED_BODY()

public:	
  // Sets default values for this component's properties
  UEMGPlayerInventory();

  UPROPERTY(EditAnywhere,BlueprintReadWrite)
  float InventoryCapacity = 10;

  UPROPERTY()
  float InitialInventoryCapacity;

  UPROPERTY(EditAnywhere,BlueprintReadWrite)
  float ItemCount;
  
  UPROPERTY(EditAnywhere,BlueprintReadWrite)
  float ItemSpace;

  UPROPERTY()
  bool bIsWeightAffectingMovement = true;

  UPROPERTY(EditAnywhere,BlueprintReadWrite)
  TArray&ltFItemsInInventory&gt PlayerInventory;
  
  UPROPERTY(EditAnywhere,BlueprintReadWrite)
  float TotalValueCollected;

  UPROPERTY(BlueprintReadOnly)
  ACharacter* PlayerRef;

  UFUNCTION(Server,Reliable,BlueprintCallable)
  void Server_AddItemToInventory(FItemsInInventory ItemToAdd);
  
  UFUNCTION(NetMulticast, Reliable,BlueprintCallable)
  void Multicast_AddToInventory(FItemsInInventory ItemsInInventory);

  UFUNCTION(Server,Reliable,BlueprintCallable)
  void Server_AddMultipleItemsToInventory(const TArray&ltFItemsInInventory&gt& ItemsToAdd);

  UFUNCTION(NetMulticast, Reliable,BlueprintCallable)
  void Multicast_AddMultipleItemsToInventory(const TArray&ltFItemsInInventory&gt& ItemsToAdd);

  UFUNCTION(Server,Reliable,BlueprintCallable)
  void Server_RemoveLastItem();
  
  UFUNCTION(NetMulticast,Reliable,BlueprintCallable)
  void MulticastRemoveLastItem();

  UFUNCTION(Server,Reliable,BlueprintCallable)
  void Server_RemoveFirstItem();
  
  UFUNCTION(NetMulticast,Reliable,BlueprintCallable)
  void MulticastRemoveFirstItem();

  UFUNCTION()
  void UpdateTotalValueCollected();


  UFUNCTION(Server,Reliable, BlueprintCallable)
  void Server_EmptyInventory();

  UFUNCTION(NetMulticast,Reliable)
  void Multicast_EmptyInventory();

  UFUNCTION()
  void UpdatePlayersCartWeight();

  UFUNCTION(BlueprintCallable)
  FORCEINLINE bool IsFull() const
  {
    return ItemSpace == 0;
  }

  UPROPERTY(BlueprintAssignable)
  FOnAddInventoryItem OnAddItemToInventory;
  UPROPERTY(BlueprintAssignable)
  FOnRemoveInventoryItem OnRemoveInventoryItem;
  UPROPERTY(BlueprintAssignable)
  FOnCheckOut OnCheckOut;

protected:

  // Called when the game starts
  virtual void BeginPlay() override;

  UPROPERTY(EditAnywhere,BlueprintReadOnly, Category="Item Slowdown Multipliers")
  float MaxAccelerationMutliplier;

  UPROPERTY(EditAnywhere,BlueprintReadOnly, Category="Item Slowdown Multipliers")
  float MaxSpeedMultiplier;

  UPROPERTY(EditAnywhere,BlueprintReadOnly, Category="Item Slowdown Multipliers")
  float MassMultiplier;

  UPROPERTY(EditAnywhere,BlueprintReadOnly, Category="Item Slowdown Multipliers")
  float FrictionMultiplier;

public:	
  // Called every frame
  virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

    
};
</code></pre>
<!--=======================================================================================================================================================================-->

<h5 class="my-4">Collecting Items</h5>
<p>  
  The method for storing items into the cart is fairly simple. Each Shopping Item holds a variable of the FItemsInInventory type which, when a player interacts with it (and if there is
  still space remaining for the item in the inventory), will be copied into an array of FItemsInInventory inside of the player inventory. In order for the server and clients to 
  have proper knowledge of the item that was stored and it's weight, size and monetary values, the function needed to be called with an RPC:

</p>
<br>
<!--====================================================Add item to inventory RPC===================================================================-->

<pre class="pre-scrollable"><code class=" language-cpp">  
void UEMGPlayerInventory::Server_AddItemToInventory_Implementation(FItemsInInventory ItemToAdd)
{
  Multicast_AddToInventory(ItemToAdd);
}

//Adds new collected item to the players inventory
void UEMGPlayerInventory::Multicast_AddToInventory_Implementation(FItemsInInventory ItemsInInventory)
{
	//Add the new item as a copy
	ItemCount += ItemsInInventory.ItemSize;
	ItemSpace -= ItemsInInventory.ItemSize;

	PlayerInventory.Add(ItemsInInventory);
	UpdateTotalValueCollected();
	OnAddItemToInventory.Broadcast(ItemsInInventory);

	//TODO: Implement logic for affecting the players movement
	UpdatePlayersCartWeight();
}
</code></pre>
<!--==========================================================================================================================================================-->
<div class="my-5">
  <div class="row text-center">
    <div class="col-3"></div>
    <img src="./Images/EMG/emgCollectItemGIF.gif" class="img-fluid col-6">
  </div>
</div>

<div class="mt-auto text-center">
  <a href="https://vfs-gdpg.itch.io/everything-must-go" class="btn btn-primary">Link to VFS Arcade</a>
</div>
asdfsda
      </div>
    </div>
  </div>
</div>

<!--==============================================================================================================-->


<!--======================================================================================================================================-->




    </div>
  </div>
</div>

<!---------------------------------------------------End of accordion--------------------------------------------------------->
    
    </div> 
    </div>
    </section>
  
    </main>
<!--=========================================================================================================================-->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
<script src="./scripts/index.js"></script>
<script src="./prism/prism.js"></script>
</body>
</html>